<!doctype html><html lang=en><meta charset=utf-8><meta name=generator content="Hugo 0.135.0"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=color-scheme content="light dark"><meta name=supported-color-schemes content="light dark"><title>Clocks, Event Ordering and Lamport&nbsp;&ndash;&nbsp;$> cat /var/log/e770r</title><link rel=stylesheet href=/css/core.min.63f706677e61b4ee62b8daf083358d3bbf8ac8ab03c7d171af3180fab3a3ebb83efb79fb98674f13dde6db11de2bf694.css integrity=sha384-Y/cGZ35htO5iuNrwgzWNO7+KyKsDx9FxrzGA+rOj67g++3n7mGdPE93m2xHeK/aU><meta name=twitter:card content="summary">
<meta name=twitter:title content="Clocks, Event Ordering and Lamport"><body><section id=header><div class="header wrap"><span class="header left-side"><a class="site home" href=/><img class="site logo" src="https://avatars.githubusercontent.com/u/53065463?v=4" alt><span class="site name">$> cat /var/log/e770r</span></a></span>
<span class="header right-side"><div class="nav wrap"><nav class=nav><a class="nav item" href=/categories/>Categories</a><a class="nav item" href=/tags/>Tags</a></nav></div></span></div><div class="site slogan"><span class=title>logging my experiences one blog at a time ~</span></div></section><section id=content><div class=article-container><section class="article header"><h1 class="article title">Clocks, Event Ordering and Lamport</h1><p class="article date">2024-10-11</p></section><article class="article markdown-body"><p>The order in which event&rsquo;s occur is an interesting topic and lately i have been thinking about it a lot. Particularly in the context of distributed systems.</p><p>The rationale behind my thinking is fairly simple. In a large distributed system, how does the system maintain order ? Better still how does each process know which event came first?</p><p>Before the rambling continues, perhaps i should start by defining what an <em>event</em> is. An <em>event</em> simply refers an occurrence or action within a process. This could include sending or receiving a message or some kind of local action such as writing to disk.</p><h2 id=what-happened-to-timestamps>What happened to timestamps?</h2><p>Time stamps are great and are easy to reason about. process $$a$$ and $$b$$ receive an event at time <em>t</em> .</p><p>Determining which event came first is a matter of comparing timestamps:</p><ul><li>Let $$t_a$$ be the timestamp of the event in process $$a$$</li><li>Let $$t_b$$ be the timestamp of the event in process $$b$$</li></ul><p>We can represent this mathematically as:</p><p>$$
\begin{aligned}
t_a &: \text{timestamp of event in process } a \
t_b &: \text{timestamp of event in process } b
\end{aligned}
$$</p><p>If $$t_a &lt; t_b$$, we can conclude that the event in process $$a$$ occurred first.</p><p>We use the notation $$a \rightarrow b$$ to denote that event $$a$$ happens before event $$b$$.</p><p>For example, to say that an event in process $$a$$ happens before an event in process $$b$$, we write:</p><p>$$
t_a \rightarrow t_b
$$</p><p>This is read as &ldquo;the event at time $$t_a$$ happens before the event at time $$t_b$$&rdquo;.</p><p>Easy enough, but things start to fall apart we have to account for something called clock skew. Clock skew occurs when the internal clocks of different computers are not perfectly synchronized.</p><p>Even in the same data center, two processes running on separate machines can experience clock skew due to factors such as clock crystals may ticking at slightly different rates, latency in the NTP protocol.</p><p>That being said, order in distributed systems can be divided in two type. Partial and total order.</p><h3 id=partial-vs-total-order>Partial vs Total Order</h3><p>The human mind views time as linear, AKA event $$a$$ $$\rightarrow$$ $$b$$ $$\rightarrow$$ $$c$$ as time passes.</p><p>This is an easy way to think of the concept of <a href=https://en.wikipedia.org/wiki/Total_order target=_blank rel="noopener noreferrer">total order</a> where every element in a set is comparable or every element can be placed in a definite sequence , therefore we can say the system can be totally ordered.
<img src="https://github.com/s1ntaxe770r/blog/blob/master/content/posts/linear-time.png?raw=true" alt=lineartime>
As you might have guess partial ordering is the opposite(kind of). Mathematically, it can be defined as a set in which some pairs of events, we can determine their order, but for others, we cannot.</p><p>In a distributed system, events $$a$$ and $$b$$ on different processes might be concurrent ($$a || b$$), meaning we can&rsquo;t determine which happened first.</p><h2 id=what-about-leslie>What about Leslie?</h2><p>In 1978 <a href="https://www.google.com/search?client=safari&amp;rls=en&amp;q=leslie+lamport&amp;ie=UTF-8&amp;oe=UTF-8" target=_blank rel="noopener noreferrer">Leslie Lamport</a> wrote a paper titled &ldquo;Time, Clocks, and the Ordering of Events in a Distributed System&rdquo;, he proposed the concept of logical clocks(lamport clocks) , which provide a way to assign timestamps to events in a distributed system without relying on physical clocks.</p><p>Part of why this post even exists is because I needed an excuse to implement a Lamport clock, which we will get to shortly.</p><h2 id=implementing--a-lamport-clock>Implementing a Lamport Clock</h2><p>I highly doubt my implementation is great but reading and implementing concepts from and academic paper was a fun exercise.</p><p>I began by creating an enum to represent of the three possible events the paper outlines:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>type</span> Event <span style=color:#8be9fd>int</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>const</span> (
</span></span><span style=display:flex><span>    Send = <span style=color:#ff79c6>iota</span>
</span></span><span style=display:flex><span>    Received
</span></span><span style=display:flex><span>    Local
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><h3 id=defining-a-clock>Defining a Clock</h3><p>Next, I created a structure to represent a Lamport clock:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>type</span> LamportClock <span style=color:#8be9fd;font-style:italic>struct</span> {
</span></span><span style=display:flex><span>    counter atomic.Int32
</span></span><span style=display:flex><span>    mutext  sync.Mutex
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>using <code>atomic.Int32</code> i can somewhat guarantee thread safety , the counter here is also important because the paper states:</p><blockquote><p>we define a clock Ci for each process Pi
to be a function which assigns a number Ci(a) to any
event a in that process.</p></blockquote><p>The mutex is an implementation detail to ensure thread-safety.</p><p>Now, let&rsquo;s look at the methods:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span>(lc <span style=color:#ff79c6>*</span>LamportClock)<span style=color:#50fa7b>Tick</span>(currentClock <span style=color:#8be9fd>int32</span>) {
</span></span><span style=display:flex><span>    currentTime <span style=color:#ff79c6>:=</span> <span style=color:#8be9fd;font-style:italic>max</span>(lc.counter.<span style=color:#50fa7b>Load</span>(), currentClock) <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>1</span>
</span></span><span style=display:flex><span>    lc.counter.<span style=color:#50fa7b>Store</span>(currentTime)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span>(lc <span style=color:#ff79c6>*</span>LamportClock) <span style=color:#50fa7b>Local</span>() {
</span></span><span style=display:flex><span>    lc.counter.<span style=color:#50fa7b>Add</span>(<span style=color:#bd93f9>1</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span>(lc <span style=color:#ff79c6>*</span>LamportClock)<span style=color:#50fa7b>CurrentTimestamp</span>() <span style=color:#8be9fd>int32</span> {
</span></span><span style=display:flex><span> <span style=color:#ff79c6>return</span> lc.counter.<span style=color:#50fa7b>Load</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>Tick</code> method implements the core of Lamport&rsquo;s clock synchronization. When a message is received, the clock is updated to be greater than both its current value and the timestamp of the received message.</p><p><code>max(lc.counter.Load(), currentClock)</code> compares the local clock value with the received timestamp (<code>currentClock</code>). We need to use <code>max</code> here to ensure that the new clock value is greater than both</p><p>The local clock value (to maintain the local process order) and the received timestamp (to respect the &ldquo;happens-before&rdquo; relationship with the sending process)</p><p>The <code>Local</code> method increments the counter for local events. As Lamport put it:</p><blockquote><p>Each process $$P_i$$ increments Ci between any two successive events.</p></blockquote><p>The <code>CurrentTimestamp</code> method simply returns the current value of the logical clock, which can be used when sending messages to other processes.</p><h3 id=processes>Processes</h3><p>Here i tried to model individual processes or services as nodes in a distributed system.</p><p>Each node has its own Lamport clock and can send and receive messages.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>type</span> Node <span style=color:#8be9fd;font-style:italic>interface</span> {
</span></span><span style=display:flex><span>    <span style=color:#50fa7b>Send</span>(CurrentTimestamp <span style=color:#8be9fd>int32</span>) <span style=color:#8be9fd>int32</span>
</span></span><span style=display:flex><span>    <span style=color:#50fa7b>Receive</span>(event clock.Event, timestamp <span style=color:#8be9fd>int32</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I also needed to define a <code>Message</code> struct to represent the messages exchanged between nodes:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>type</span> Message <span style=color:#8be9fd;font-style:italic>struct</span> {
</span></span><span style=display:flex><span>    SenderID  <span style=color:#8be9fd>string</span>
</span></span><span style=display:flex><span>    Timestamp <span style=color:#8be9fd>int32</span>
</span></span><span style=display:flex><span>    Content   <span style=color:#8be9fd>string</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Each message contains the sender&rsquo;s ID, the Lamport timestamp, and the message content.</p><p>I used a <code>Service</code> struct to represent a process with an embedded Lamport clock:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>type</span> Service <span style=color:#8be9fd;font-style:italic>struct</span> {
</span></span><span style=display:flex><span>    Name        <span style=color:#8be9fd>string</span>
</span></span><span style=display:flex><span>    Id          <span style=color:#8be9fd>string</span>
</span></span><span style=display:flex><span>    logger      <span style=color:#ff79c6>*</span>slog.Logger
</span></span><span style=display:flex><span>    MessageChan <span style=color:#8be9fd;font-style:italic>chan</span> Message
</span></span><span style=display:flex><span>    Clock       clock.LamportClock
</span></span><span style=display:flex><span>    mutext      sync.RWMutex
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In order for the <code>Service</code> struct to implement the <code>node</code> interface i added three methods</p><p><strong>Send Method</strong>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> (s <span style=color:#ff79c6>*</span>Service) <span style=color:#50fa7b>Send</span>(CurrentTimestamp <span style=color:#8be9fd>int32</span>) <span style=color:#8be9fd>int32</span> {
</span></span><span style=display:flex><span>    s.Clock.<span style=color:#50fa7b>Local</span>()
</span></span><span style=display:flex><span>    msg <span style=color:#ff79c6>:=</span> Message{
</span></span><span style=display:flex><span>        SenderID:  s.Id,
</span></span><span style=display:flex><span>        Timestamp: s.Clock.<span style=color:#50fa7b>CurrentTimestamp</span>(),
</span></span><span style=display:flex><span>        Content:   <span style=color:#f1fa8c>&#34;HI LESLIE!!!&#34;</span>,
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    s.mutext.<span style=color:#50fa7b>Lock</span>()
</span></span><span style=display:flex><span>    s.MessageChan <span style=color:#ff79c6>&lt;-</span> msg
</span></span><span style=display:flex><span>    s.mutext.<span style=color:#50fa7b>Unlock</span>()
</span></span><span style=display:flex><span>    s.logger.<span style=color:#50fa7b>Info</span>(<span style=color:#f1fa8c>&#34;sent message&#34;</span>, <span style=color:#f1fa8c>&#34;Timestamp&#34;</span>, msg.Timestamp, <span style=color:#f1fa8c>&#34;Content&#34;</span>, msg.Content)
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> s.Clock.<span style=color:#50fa7b>CurrentTimestamp</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This method implements the sending of a message. It increments the local clock, creates a message with the current timestamp, and sends it through the message channel.</p><p>Per the paper :</p><blockquote><p>&ldquo;A process increments its counter before each event in that process.&rdquo;</p></blockquote><p>Similarly the Recieve Method:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> (s <span style=color:#ff79c6>*</span>Service) <span style=color:#50fa7b>Receive</span>(event clock.Event, timestamp <span style=color:#8be9fd>int32</span>) {
</span></span><span style=display:flex><span>    s.Clock.<span style=color:#50fa7b>Tick</span>(timestamp)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And finally a helper function for handling received messages</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> (s <span style=color:#ff79c6>*</span>Service) <span style=color:#50fa7b>HandleMessages</span>() {
</span></span><span style=display:flex><span>    s.logger.<span style=color:#50fa7b>Info</span>(<span style=color:#f1fa8c>&#34;Starting message handler&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> msg <span style=color:#ff79c6>:=</span> <span style=color:#ff79c6>range</span> s.MessageChan {
</span></span><span style=display:flex><span>        s.<span style=color:#50fa7b>Receive</span>(clock.Received, msg.Timestamp)
</span></span><span style=display:flex><span>        s.logger.<span style=color:#50fa7b>Info</span>(<span style=color:#f1fa8c>&#34;Received Message&#34;</span>, <span style=color:#f1fa8c>&#34;from&#34;</span>, msg.SenderID, <span style=color:#f1fa8c>&#34;timestamp&#34;</span>, msg.Timestamp, <span style=color:#f1fa8c>&#34;Content&#34;</span>, msg.Content)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=validating-my-implementation>Validating my Implementation</h3><p>Testing stuff like this is weird, there isn&rsquo;t exactly a guide titled &ldquo;testing your distributed system&rdquo;. But it seemed sane to write some tests to ensure the implementation worked somewhat.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>TestSingleTick</span>(t <span style=color:#ff79c6>*</span>testing.T) {
</span></span><span style=display:flex><span>	messageChan <span style=color:#ff79c6>:=</span> <span style=color:#8be9fd;font-style:italic>make</span>(<span style=color:#8be9fd;font-style:italic>chan</span> node.Message, <span style=color:#bd93f9>100</span>)
</span></span><span style=display:flex><span>	OrderService <span style=color:#ff79c6>:=</span> node.<span style=color:#50fa7b>NewService</span>(<span style=color:#f1fa8c>&#34;OrderService&#34;</span>, messageChan)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	OrderService.<span style=color:#50fa7b>Receive</span>(clock.Received, OrderService.Clock.<span style=color:#50fa7b>CurrentTimestamp</span>())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	assert.<span style=color:#50fa7b>Equal</span>(t, <span style=color:#bd93f9>1</span>, <span style=color:#8be9fd;font-style:italic>int</span>(OrderService.Clock.<span style=color:#50fa7b>CurrentTimestamp</span>()))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>TestSend</span>(t <span style=color:#ff79c6>*</span>testing.T) {
</span></span><span style=display:flex><span>	messageChan <span style=color:#ff79c6>:=</span> <span style=color:#8be9fd;font-style:italic>make</span>(<span style=color:#8be9fd;font-style:italic>chan</span> node.Message, <span style=color:#bd93f9>100</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	OrderService <span style=color:#ff79c6>:=</span> node.<span style=color:#50fa7b>NewService</span>(<span style=color:#f1fa8c>&#34;OrderService&#34;</span>, messageChan)
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>go</span> OrderService.<span style=color:#50fa7b>HandleMessages</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	PaymentService <span style=color:#ff79c6>:=</span> node.<span style=color:#50fa7b>NewService</span>(<span style=color:#f1fa8c>&#34;PaymentService&#34;</span>, messageChan)
</span></span><span style=display:flex><span>	CurrentTimestamp <span style=color:#ff79c6>:=</span> PaymentService.Clock.<span style=color:#50fa7b>CurrentTimestamp</span>()
</span></span><span style=display:flex><span>	PaymentService.<span style=color:#50fa7b>Send</span>(CurrentTimestamp)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// Give some time for the message to be processed
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	time.<span style=color:#50fa7b>Sleep</span>(<span style=color:#bd93f9>100</span> <span style=color:#ff79c6>*</span> time.Millisecond)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	assert.<span style=color:#50fa7b>Equal</span>(t, <span style=color:#bd93f9>2</span>, <span style=color:#8be9fd;font-style:italic>int</span>(OrderService.Clock.<span style=color:#50fa7b>CurrentTimestamp</span>()))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=tick--tickhttpswwwyoutubecomwatchvtqaf5w6ns88>Tick , <a href="https://www.youtube.com/watch?v=tQAF5W6NS88" target=_blank rel="noopener noreferrer">Tick</a>&mldr;</h2><p>while my doubts about my implementation still remain, I learnt a ton about more about clocks and shockingly the human perception of time. Beyond that it was great to get a way from the grasp of Kubernetes.</p><p>The full implementation is available <a href=https://github.com/s1ntaxe770r/whyport-this-clock target=_blank rel="noopener noreferrer">here</a> , also a lot of the information here wouldn&rsquo;t be possible without these amazing authors:</p><ul><li><a href=https://medium.com/outreach-prague/lamport-clocks-determining-the-order-of-events-in-distributed-systems-41a9a8489177 target=_blank rel="noopener noreferrer">Christian Galatolo</a></li><li><a href=https://blog.fponzi.me/2024-02-02-lamport-clocks.html#what-problem-are-they-trying-to-solve target=_blank rel="noopener noreferrer">Lamport Clocks by Fredrico Ponzi</a></li><li><a href=https://lamport.azurewebsites.net/pubs/time-clocks.pdf target=_blank rel="noopener noreferrer">The Original Paper</a></li><li><a href=https://book.mixu.net/distsys/time.html target=_blank rel="noopener noreferrer">Time and Order by</a> <a href=http://mixu.net/ target=_blank rel="noopener noreferrer">Mikito Takada</a>.</li></ul></article><section class="article author"><img class=avatar src="https://avatars.githubusercontent.com/u/53065463?v=4" alt><p class=name>s1ntaxe770r</p><div class=details><a class=item href=https://github.com/s1ntaxe770r target=_blank rel="noopener noreferrer"><span class="iconfont icon-github"></span>&nbsp;s1ntaxe770r</a><a class=item href=https://hub.docker.com/u/e770r target=_blank rel="noopener noreferrer"><span class="iconfont icon-docker"></span>&nbsp;e770r</a><a class=item href=https://twitter.com/s1ntaxe770r target=_blank rel="noopener noreferrer"><span class="iconfont icon-twitter"></span>&nbsp;@s1ntaxe770r</a></div></section></div><div class="article bottom"><section class="article navigation"><p><a class=link href=/posts/in-search-of-coherence/><span class="iconfont icon-article"></span>In Search of Coherence</a></p></section></div></section><section id=footer><div class=footer-wrap><p class=copyright>Â©2021 s1ntaxe770r</p><p class=powerby><span>Powered&nbsp;by&nbsp;</span><a href=https://gohugo.io target=_blank rel="noopener noreferrer">Hugo</a><span>&nbsp;&&nbsp;</span><a href=https://themes.gohugo.io/hugo-notepadium/ target=_blank rel="noopener noreferrer">Notepadium</a></p></div></section><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css integrity=sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js integrity=sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js integrity=sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI crossorigin=anonymous onload=renderMathInElement(document.body)></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-D6NJ1ZKSX9"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-D6NJ1ZKSX9")}</script></body></html>